import {
  secp256k1,
  sha256
} from "./chunk-TJ3UG4EJ.js";
import {
  equalsBytes,
  keccak256,
  utf8ToBytes
} from "./chunk-PJKG2YRM.js";
import {
  require_events
} from "./chunk-GJBZJ4UL.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/helpers.js
var assertIsBytes = function(input) {
  if (!(input instanceof Uint8Array)) {
    const msg = `This method only supports Uint8Array but input was: ${input}`;
    throw new Error(msg);
  }
};
var assertIsString = function(input) {
  if (typeof input !== "string") {
    const msg = `This method only supports strings but input was: ${input}`;
    throw new Error(msg);
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/bytes.js
var BIGINT_0 = BigInt(0);
var hexToBytesMapFirstKey = {};
var hexToBytesMapSecondKey = {};
for (let i = 0; i < 16; i++) {
  const vSecondKey = i;
  const vFirstKey = i * 16;
  const key = i.toString(16).toLowerCase();
  hexToBytesMapSecondKey[key] = vSecondKey;
  hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;
  hexToBytesMapFirstKey[key] = vFirstKey;
  hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;
}
function _unprefixedHexToBytes(hex) {
  const byteLen = hex.length;
  const bytes = new Uint8Array(byteLen / 2);
  for (let i = 0; i < byteLen; i += 2) {
    bytes[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];
  }
  return bytes;
}
var unprefixedHexToBytes = (inp) => {
  if (inp.slice(0, 2) === "0x") {
    throw new Error("hex string is prefixed with 0x, should be unprefixed");
  } else {
    return _unprefixedHexToBytes(padToEven(inp));
  }
};
var hexByByte = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
var bytesToHex2 = (bytes) => {
  let hex = "0x";
  if (bytes === void 0 || bytes.length === 0)
    return hex;
  for (const byte of bytes) {
    hex += hexByByte[byte];
  }
  return hex;
};
var BIGINT_CACHE = [];
for (let i = 0; i <= 256 * 256 - 1; i++) {
  BIGINT_CACHE[i] = BigInt(i);
}
var bytesToBigInt = (bytes, littleEndian = false) => {
  if (littleEndian) {
    bytes.reverse();
  }
  const hex = bytesToHex2(bytes);
  if (hex === "0x") {
    return BIGINT_0;
  }
  if (hex.length === 4) {
    return BIGINT_CACHE[bytes[0]];
  }
  if (hex.length === 6) {
    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]];
  }
  return BigInt(hex);
};
var hexToBytes = (hex) => {
  if (typeof hex !== "string") {
    throw new Error(`hex argument type ${typeof hex} must be of type string`);
  }
  if (!/^0x[0-9a-fA-F]*$/.test(hex)) {
    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);
  }
  hex = hex.slice(2);
  if (hex.length % 2 !== 0) {
    hex = padToEven(hex);
  }
  return _unprefixedHexToBytes(hex);
};
var intToHex = (i) => {
  if (!Number.isSafeInteger(i) || i < 0) {
    throw new Error(`Received an invalid integer type: ${i}`);
  }
  return `0x${i.toString(16)}`;
};
var intToBytes = (i) => {
  const hex = intToHex(i);
  return hexToBytes(hex);
};
var bigIntToBytes = (num, littleEndian = false) => {
  const bytes = toBytes("0x" + padToEven(num.toString(16)));
  return littleEndian ? bytes.reverse() : bytes;
};
var zeros = (bytes) => {
  return new Uint8Array(bytes);
};
var setLength = (msg, length, right) => {
  if (right) {
    if (msg.length < length) {
      return new Uint8Array([...msg, ...zeros(length - msg.length)]);
    }
    return msg.subarray(0, length);
  } else {
    if (msg.length < length) {
      return new Uint8Array([...zeros(length - msg.length), ...msg]);
    }
    return msg.subarray(-length);
  }
};
var setLengthLeft = (msg, length) => {
  assertIsBytes(msg);
  return setLength(msg, length, false);
};
var stripZeros = (a) => {
  let first = a[0];
  while (a.length > 0 && first.toString() === "0") {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
var unpadBytes = (a) => {
  assertIsBytes(a);
  return stripZeros(a);
};
var toBytes = (v) => {
  if (v === null || v === void 0) {
    return new Uint8Array();
  }
  if (Array.isArray(v) || v instanceof Uint8Array) {
    return Uint8Array.from(v);
  }
  if (typeof v === "string") {
    if (!isHexString(v)) {
      throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);
    }
    return hexToBytes(v);
  }
  if (typeof v === "number") {
    return intToBytes(v);
  }
  if (typeof v === "bigint") {
    if (v < BIGINT_0) {
      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
    }
    let n = v.toString(16);
    if (n.length % 2)
      n = "0" + n;
    return unprefixedHexToBytes(n);
  }
  if (v.toBytes !== void 0) {
    return v.toBytes();
  }
  throw new Error("invalid type");
};
var addHexPrefix = (str) => {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed(str) ? str : "0x" + str;
};
var validateNoLeadingZeroes = (values) => {
  for (const [k, v] of Object.entries(values)) {
    if (v !== void 0 && v.length > 0 && v[0] === 0) {
      throw new Error(`${k} cannot have leading zeroes, received: ${bytesToHex2(v)}`);
    }
  }
};
var bigIntToHex = (num) => {
  return "0x" + num.toString(16);
};
var bigIntToUnpaddedBytes = (value) => {
  return unpadBytes(bigIntToBytes(value));
};
var concatBytes = (...arrays) => {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/internal.js
function isHexPrefixed(str) {
  if (typeof str !== "string") {
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
  }
  return str[0] === "0" && str[1] === "x";
}
var stripHexPrefix = (str) => {
  if (typeof str !== "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
  return isHexPrefixed(str) ? str.slice(2) : str;
};
function padToEven(value) {
  let a = value;
  if (typeof a !== "string") {
    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
  }
  if (a.length % 2)
    a = `0${a}`;
  return a;
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
    return false;
  if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
    return false;
  return true;
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/constants.js
var MAX_UINT64 = BigInt("0xffffffffffffffff");
var MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
var SECP256K1_ORDER = secp256k1.CURVE.n;
var SECP256K1_ORDER_DIV_2 = secp256k1.CURVE.n / BigInt(2);
var TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var KECCAK256_NULL = hexToBytes(KECCAK256_NULL_S);
var KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
var KECCAK256_RLP_ARRAY = hexToBytes(KECCAK256_RLP_ARRAY_S);
var KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
var KECCAK256_RLP = hexToBytes(KECCAK256_RLP_S);
var RLP_EMPTY_STRING = Uint8Array.from([128]);
var BIGINT_NEG1 = BigInt(-1);
var BIGINT_02 = BigInt(0);
var BIGINT_1 = BigInt(1);
var BIGINT_2 = BigInt(2);
var BIGINT_3 = BigInt(3);
var BIGINT_7 = BigInt(7);
var BIGINT_8 = BigInt(8);
var BIGINT_27 = BigInt(27);
var BIGINT_28 = BigInt(28);
var BIGINT_31 = BigInt(31);
var BIGINT_32 = BigInt(32);
var BIGINT_64 = BigInt(64);
var BIGINT_128 = BigInt(128);
var BIGINT_255 = BigInt(255);
var BIGINT_256 = BigInt(256);
var BIGINT_96 = BigInt(96);
var BIGINT_100 = BigInt(100);
var BIGINT_160 = BigInt(160);
var BIGINT_224 = BigInt(224);
var BIGINT_2EXP96 = BigInt(7922816251426434e13);
var BIGINT_2EXP160 = BigInt(1461501637330903e33);
var BIGINT_2EXP224 = BigInt(2695994666715064e52);
var BIGINT_2EXP256 = BIGINT_2 ** BIGINT_256;

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/rlp/dist/esm/index.js
function encode(input) {
  if (Array.isArray(input)) {
    const output = [];
    let outputLength = 0;
    for (let i = 0; i < input.length; i++) {
      const encoded = encode(input[i]);
      output.push(encoded);
      outputLength += encoded.length;
    }
    return concatBytes2(encodeLength(outputLength, 192), ...output);
  }
  const inputBuf = toBytes2(input);
  if (inputBuf.length === 1 && inputBuf[0] < 128) {
    return inputBuf;
  }
  return concatBytes2(encodeLength(inputBuf.length, 128), inputBuf);
}
function safeSlice(input, start, end) {
  if (end > input.length) {
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  }
  return input.slice(start, end);
}
function decodeLength(v) {
  if (v[0] === 0) {
    throw new Error("invalid RLP: extra zeros");
  }
  return parseHexByte(bytesToHex3(v));
}
function encodeLength(len, offset) {
  if (len < 56) {
    return Uint8Array.from([len + offset]);
  }
  const hexLength = numberToHex(len);
  const lLength = hexLength.length / 2;
  const firstByte = numberToHex(offset + 55 + lLength);
  return Uint8Array.from(hexToBytes2(firstByte + hexLength));
}
function decode(input, stream = false) {
  if (typeof input === "undefined" || input === null || input.length === 0) {
    return Uint8Array.from([]);
  }
  const inputBytes = toBytes2(input);
  const decoded = _decode(inputBytes);
  if (stream) {
    return {
      data: decoded.data,
      remainder: decoded.remainder.slice()
    };
  }
  if (decoded.remainder.length !== 0) {
    throw new Error("invalid RLP: remainder must be zero");
  }
  return decoded.data;
}
function _decode(input) {
  let length, llength, data, innerRemainder, d;
  const decoded = [];
  const firstByte = input[0];
  if (firstByte <= 127) {
    return {
      data: input.slice(0, 1),
      remainder: input.subarray(1)
    };
  } else if (firstByte <= 183) {
    length = firstByte - 127;
    if (firstByte === 128) {
      data = Uint8Array.from([]);
    } else {
      data = safeSlice(input, 1, length);
    }
    if (length === 2 && data[0] < 128) {
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    }
    return {
      data,
      remainder: input.subarray(length)
    };
  } else if (firstByte <= 191) {
    llength = firstByte - 182;
    if (input.length - 1 < llength) {
      throw new Error("invalid RLP: not enough bytes for string length");
    }
    length = decodeLength(safeSlice(input, 1, llength));
    if (length <= 55) {
      throw new Error("invalid RLP: expected string length to be greater than 55");
    }
    data = safeSlice(input, llength, length + llength);
    return {
      data,
      remainder: input.subarray(length + llength)
    };
  } else if (firstByte <= 247) {
    length = firstByte - 191;
    innerRemainder = safeSlice(input, 1, length);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(length)
    };
  } else {
    llength = firstByte - 246;
    length = decodeLength(safeSlice(input, 1, llength));
    if (length < 56) {
      throw new Error("invalid RLP: encoded list too short");
    }
    const totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error("invalid RLP: total length is larger than the data");
    }
    innerRemainder = safeSlice(input, llength, totalLength);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(totalLength)
    };
  }
}
var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex3(uint8a) {
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += cachedHexes[uint8a[i]];
  }
  return hex;
}
function parseHexByte(hexByte) {
  const byte = Number.parseInt(hexByte, 16);
  if (Number.isNaN(byte))
    throw new Error("Invalid byte sequence");
  return byte;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    array[i] = parseHexByte(hex.slice(j, j + 2));
  }
  return array;
}
function concatBytes2(...arrays) {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function utf8ToBytes2(utf) {
  return new TextEncoder().encode(utf);
}
function numberToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  const hex = integer.toString(16);
  return hex.length % 2 ? `0${hex}` : hex;
}
function padToEven2(a) {
  return a.length % 2 ? `0${a}` : a;
}
function isHexPrefixed2(str) {
  return str.length >= 2 && str[0] === "0" && str[1] === "x";
}
function stripHexPrefix2(str) {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed2(str) ? str.slice(2) : str;
}
function toBytes2(v) {
  if (v instanceof Uint8Array) {
    return v;
  }
  if (typeof v === "string") {
    if (isHexPrefixed2(v)) {
      return hexToBytes2(padToEven2(stripHexPrefix2(v)));
    }
    return utf8ToBytes2(v);
  }
  if (typeof v === "number" || typeof v === "bigint") {
    if (!v) {
      return Uint8Array.from([]);
    }
    return hexToBytes2(numberToHex(v));
  }
  if (v === null || v === void 0) {
    return Uint8Array.from([]);
  }
  throw new Error("toBytes: received unsupported type " + typeof v);
}
var RLP = { encode, decode };

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/types.js
var TypeOutput;
(function(TypeOutput2) {
  TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
  TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
  TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
  TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));
function toType(input, outputType) {
  if (input === null) {
    return null;
  }
  if (input === void 0) {
    return void 0;
  }
  if (typeof input === "string" && !isHexString(input)) {
    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
  } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
    throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
  }
  const output = toBytes(input);
  switch (outputType) {
    case TypeOutput.Uint8Array:
      return output;
    case TypeOutput.BigInt:
      return bytesToBigInt(output);
    case TypeOutput.Number: {
      const bigInt = bytesToBigInt(output);
      if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
      }
      return Number(bigInt);
    }
    case TypeOutput.PrefixedHexString:
      return bytesToHex2(output);
    default:
      throw new Error("unknown outputType");
  }
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/blobs.js
var BYTES_PER_FIELD_ELEMENT = 32;
var FIELD_ELEMENTS_PER_BLOB = 4096;
var USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
var MAX_BLOBS_PER_TX = 2;
var MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;
var BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;
function get_padded(data, blobs_len) {
  const pdata = new Uint8Array(blobs_len * USEFUL_BYTES_PER_BLOB).fill(0);
  pdata.set(data);
  pdata[data.byteLength] = 128;
  return pdata;
}
function get_blob(data) {
  const blob = new Uint8Array(BLOB_SIZE);
  for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {
    const chunk = new Uint8Array(32);
    chunk.set(data.subarray(i * 31, (i + 1) * 31), 0);
    blob.set(chunk, i * 32);
  }
  return blob;
}
var getBlobs = (input) => {
  const data = utf8ToBytes(input);
  const len = data.byteLength;
  if (len === 0) {
    throw Error("invalid blob data");
  }
  if (len > MAX_USEFUL_BYTES_PER_TX) {
    throw Error("blob data is too large");
  }
  const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);
  const pdata = get_padded(data, blobs_len);
  const blobs = [];
  for (let i = 0; i < blobs_len; i++) {
    const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);
    const blob = get_blob(chunk);
    blobs.push(blob);
  }
  return blobs;
};
var blobsToCommitments = (kzg, blobs) => {
  const commitments = [];
  for (const blob of blobs) {
    commitments.push(kzg.blobToKzgCommitment(blob));
  }
  return commitments;
};
var blobsToProofs = (kzg, blobs, commitments) => {
  const proofs = blobs.map((blob, ctx) => kzg.computeBlobKzgProof(blob, commitments[ctx]));
  return proofs;
};
var computeVersionedHash = (commitment, blobCommitmentVersion) => {
  const computedVersionedHash = new Uint8Array(32);
  computedVersionedHash.set([blobCommitmentVersion], 0);
  computedVersionedHash.set(sha256(commitment).subarray(1), 1);
  return computedVersionedHash;
};
var commitmentsToVersionedHashes = (commitments) => {
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(computeVersionedHash(commitment, 1));
  }
  return hashes;
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/provider.js
var fetchFromProvider = async (url, params) => {
  const data = JSON.stringify({
    method: params.method,
    params: params.params,
    jsonrpc: "2.0",
    id: 1
  });
  const res = await fetch(url, {
    headers: {
      "content-type": "application/json"
    },
    method: "POST",
    body: data
  });
  if (!res.ok) {
    throw new Error(`JSONRpcError: ${JSON.stringify({
      method: params.method,
      status: res.status,
      message: await res.text().catch(() => {
        return "Could not parse error message likely because of a network error";
      })
    }, null, 2)}`);
  }
  const json = await res.json();
  return json.result;
};
var getProvider = (provider) => {
  if (typeof provider === "string") {
    return provider;
  } else if (typeof provider === "object" && provider._getConnection !== void 0) {
    return provider._getConnection().url;
  } else {
    throw new Error("Must provide valid provider URL or Web3Provider");
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/units.js
var GWEI_TO_WEI = BigInt(1e9);

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/account.js
var isValidAddress = function(hexAddress) {
  try {
    assertIsString(hexAddress);
  } catch (e) {
    return false;
  }
  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
};
var generateAddress = function(from, nonce) {
  assertIsBytes(from);
  assertIsBytes(nonce);
  if (bytesToBigInt(nonce) === BIGINT_02) {
    return keccak256(RLP.encode([from, Uint8Array.from([])])).subarray(-20);
  }
  return keccak256(RLP.encode([from, nonce])).subarray(-20);
};
var generateAddress2 = function(from, salt, initCode) {
  assertIsBytes(from);
  assertIsBytes(salt);
  assertIsBytes(initCode);
  if (from.length !== 20) {
    throw new Error("Expected from to be of length 20");
  }
  if (salt.length !== 32) {
    throw new Error("Expected salt to be of length 32");
  }
  const address = keccak256(concatBytes(hexToBytes("0xff"), from, salt, keccak256(initCode)));
  return address.subarray(-20);
};
var pubToAddress = function(pubKey, sanitize = false) {
  assertIsBytes(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
  }
  if (pubKey.length !== 64) {
    throw new Error("Expected pubKey to be of length 64");
  }
  return keccak256(pubKey).subarray(-20);
};
var publicToAddress = pubToAddress;
var privateToPublic = function(privateKey) {
  assertIsBytes(privateKey);
  return secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1);
};
var privateToAddress = function(privateKey) {
  return publicToAddress(privateToPublic(privateKey));
};
var emptyUint8Arr = new Uint8Array(0);

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/address.js
var Address = class _Address {
  constructor(bytes) {
    if (bytes.length !== 20) {
      throw new Error("Invalid address length");
    }
    this.bytes = bytes;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new _Address(zeros(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(str) {
    if (!isValidAddress(str)) {
      throw new Error("Invalid address");
    }
    return new _Address(toBytes(str));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(pubKey) {
    if (!(pubKey instanceof Uint8Array)) {
      throw new Error("Public key should be Uint8Array");
    }
    const bytes = pubToAddress(pubKey);
    return new _Address(bytes);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(privateKey) {
    if (!(privateKey instanceof Uint8Array)) {
      throw new Error("Private key should be Uint8Array");
    }
    const bytes = privateToAddress(privateKey);
    return new _Address(bytes);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(from, nonce) {
    if (typeof nonce !== "bigint") {
      throw new Error("Expected nonce to be a bigint");
    }
    return new _Address(generateAddress(from.bytes, bigIntToBytes(nonce)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(from, salt, initCode) {
    if (!(salt instanceof Uint8Array)) {
      throw new Error("Expected salt to be a Uint8Array");
    }
    if (!(initCode instanceof Uint8Array)) {
      throw new Error("Expected initCode to be a Uint8Array");
    }
    return new _Address(generateAddress2(from.bytes, salt, initCode));
  }
  /**
   * Is address equal to another.
   */
  equals(address) {
    return equalsBytes(this.bytes, address.bytes);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(_Address.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const address = bytesToBigInt(this.bytes);
    const rangeMin = BIGINT_02;
    const rangeMax = BigInt("0xffff");
    return address >= rangeMin && address <= rangeMax;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return bytesToHex2(this.bytes);
  }
  /**
   * Returns a new Uint8Array representation of address.
   */
  toBytes() {
    return new Uint8Array(this.bytes);
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/db.js
var KeyEncoding;
(function(KeyEncoding2) {
  KeyEncoding2["String"] = "string";
  KeyEncoding2["Bytes"] = "view";
  KeyEncoding2["Number"] = "number";
})(KeyEncoding || (KeyEncoding = {}));
var ValueEncoding;
(function(ValueEncoding2) {
  ValueEncoding2["String"] = "string";
  ValueEncoding2["Bytes"] = "view";
  ValueEncoding2["JSON"] = "json";
})(ValueEncoding || (ValueEncoding = {}));

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/signature.js
function ecsign(msgHash, privateKey, chainId) {
  const sig = secp256k1.sign(msgHash, privateKey);
  const buf = sig.toCompactRawBytes();
  const r = buf.slice(0, 32);
  const s = buf.slice(32, 64);
  const v = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BIGINT_2;
  return { r, s, v };
}
function calculateSigRecovery(v, chainId) {
  if (v === BIGINT_02 || v === BIGINT_1)
    return v;
  if (chainId === void 0) {
    return v - BIGINT_27;
  }
  return v - (chainId * BIGINT_2 + BigInt(35));
}
function isValidSigRecovery(recovery) {
  return recovery === BIGINT_02 || recovery === BIGINT_1;
}
var ecrecover = function(msgHash, v, r, s, chainId) {
  const signature = concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32));
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  const sig = secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
  const senderPubKey = sig.recoverPublicKey(msgHash);
  return senderPubKey.toRawBytes(false).slice(1);
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/asyncEventEmitter.js
var import_events = __toESM(require_events(), 1);

export {
  isHexPrefixed,
  stripHexPrefix,
  bytesToHex2 as bytesToHex,
  bytesToBigInt,
  hexToBytes,
  intToHex,
  intToBytes,
  setLengthLeft,
  unpadBytes,
  toBytes,
  addHexPrefix,
  validateNoLeadingZeroes,
  bigIntToHex,
  bigIntToUnpaddedBytes,
  concatBytes,
  MAX_UINT64,
  MAX_INTEGER,
  SECP256K1_ORDER_DIV_2,
  BIGINT_02 as BIGINT_0,
  BIGINT_1,
  BIGINT_2,
  BIGINT_8,
  BIGINT_27,
  RLP,
  publicToAddress,
  Address,
  TypeOutput,
  toType,
  ecsign,
  ecrecover,
  getBlobs,
  blobsToCommitments,
  blobsToProofs,
  computeVersionedHash,
  commitmentsToVersionedHashes,
  fetchFromProvider,
  getProvider
};
//# sourceMappingURL=chunk-BG4ZPY4O.js.map
